{
	// Transformation operators

	buffer: {
		categories: [
			"data",
			"time",
			"transformation",
		],
 		img: "buffer.png",
		description: "Buffers the incoming Observable values until the given {{closingNotifier}} Observable emits \
a value at which point it emits the buffer on the output Observable and starts a new buffer internally, \
awaiting the next {{timeclosingNotifier}} emits.",
	},

	bufferTime: {
		categories: [
			"data",
			"time",
			"transformation",
		],
		img: "bufferTime.png",
		description: "It is like calling `buffer(interval(time))`.  \
Buffers values from the source for a specific time duration {{bufferTimeSpan}}. Unless the optional argument\
{{bufferCreationInterval}} is given, it emits and resets the buffer every {{bufferTimeSpan}} milliseconds.  \
If {{bufferCreationInterval}} is given, this operator opens the buffer every {{bufferCreationInterval}} milliseconds \
and closes (emits and resets) the buffer every {{bufferTimeSpan}} milliseconds.  \
When the optional argument {{maxBufferSize}} is specified, the buffer will be closed either after {{bufferTimeSpan}} \
milliseconds or when it contains {{maxBufferSize}} elements."
	},

	bufferCount: {
		categories: [
			"data",
			"time",
			"transformation",
		],
		img: "bufferCount.png",
		description: "Buffers the source Observable values until the size hits the maximum {{bufferSize}} given.",
	},

	bufferToggle: {
		categories: [
			"data",
			"time",
			"transformation",
			"filter",
		],
		img: "bufferToggle.png",
		description: "Collects values from the past as an array. Starts collecting only when {{opening}} emits, \
and calls the {{closingSelector}} function to get an Observable that tells when to close the buffer.",
	},

	bufferWhen: {
		categories: [
			"data",
			"time",
			"transformation",
		],
		img: "bufferWhen.png",
		description: "Opens a buffer immediately, then closes the buffer when the observable returned by calling \
{{closingSelector}} function emits a value.  \
When it closes the buffer, it immediately opens a new buffer and repeats the process.",
	},

	window: {
		categories: [
			"subscription",
			"transformation",
		],
		img: "window.png",
		description: "Returns an Observable that emits windows of items it collects from the source Observable. \
The output Observable emits connected, non-overlapping windows.  \
It emits the current window and opens a new one whenever the Observable {{windowBoundaries}} emits an item. \
Because each window is an Observable, the output is a higher-order Observable.  \
It's like buffer, but emits a nested Observable instead of an array.",
	},

	windowCount: {
		categories: [
			"subscription",
			"transformation",
		],
		img: "windowCount.png",
		description: "Branch out the source Observable values as a nested Observable with each nested Observable \
emitting at most {{windowSize}} values.",
	},

	windowTime: {
		categories: [
			"subscription",
			"transformation",
			"filter",
		],
		img: "windowTime.png",
		description: "Branch out the source Observable values as a nested Observable periodically in time.  \
It's like {{bufferTime}}, but emits a nested Observable instead of an array.",
	},

	windowToggle: {
		categories: [
			"subscription",
			"transformation",
			"filter",
		],
		img: "windowToggle.png",
		description: "Returns an Observable that emits windows of items it collects from the source Observable. \
The output Observable emits windows that contain those items emitted by the source Observable between the time when \
the {{openings}} Observable emits an item and when the Observable returned by {{closingSelector}} emits an item.",
	},

	windowWhen: {
		categories: [
			"subscription",
			"transformation",
		],
		img: "windowWhen.png",
		description: "Returns an Observable that emits windows of items it collects from the source Observable. \
The output Observable emits connected, non-overlapping windows. It emits the current window and opens \
a new one whenever the Observable produced by the specified {{closingSelector}} function emits an item.  \
The first window is opened immediately when subscribing to the output Observable.",
	},

	concatMap: {
		categories: [
			"subscription",
			"transformation",
			"data",
			"time",
		],
		img: "concatMap.png",
		description: "Projects each source value to an Observable which is merged in the output Observable, \
in a serialized fashion, waiting for each projected observable to complete before merging the next.",
	},

	concatMapTo: {
		categories: [
			"subscription",
			"transformation",
			"data",
			"time",
		],
		img: "concatMapTo.png",
		description: "Projects each source value to the ***same*** Observable which is merged multiple times in \
a serialized fashion on the output Observable.",
	},

	exhaustMap: {
		categories: [
			"subscription",
			"transformation",
			"data",
			"time",
			"filter",
		],
		img: "exhaustMap.png",
		description: 'Returns an Observable that emits items based on applying a function that you supply to \
each item emitted by the source Observable, where that function returns an (so-called "inner") Observable. \
When it projects a source value to an Observable, the output Observable begins emitting the items emitted \
by that projected Observable.  \
*However, {{exhaustMap}} ignores every new projected Observable if the previous projected Observable has \
not yet completed.* Once that one completes, it will accept and flatten the next projected Observable and \
repeat this process.'
	},

	mergeMap: {
		categories: [
			"transformation",
			"data",
		],
		img: "mergeMap.png",
		description: "Projects each source value to an Observable which is merged with all projected observables, \
in the output Observable.",
	},

	mergeMapTo: {
		categories: [
			"transformation",
			"data",
		],
		img: "mergeMapTo.png",
		description: "Projects each source value to the ***same*** Observable which is merged multiple times \
in the output Observable.",
	},

	expand: {
		categories: [
			"subscription",
			"transformation",
			"data",
			"time",
		],
		img: "expand.png",,
		description: "Recursively projects each source value to an Observable which is merged in \
the output Observable.  \
It's similar to {{mergeMap}}, but applies the projection function to every source value as well as every output \
value.  It's recursive.",
	},

	switchMap: {
		categories: [
			"subscription",
			"transformation",
			"data",
			"filter",
		],
		img: "switchMap.png",
		description: "Projects each source value to an Observable which is merged in the output Observable, \
emitting values only from the most recently projected Observable.  \
It's like m{{ergeMap}}, only that whenever new source value is emitted, the observable projected from \
the previous value is unsubscribed.",
	},

	switchMapTo: {
		categories: [
			"subscription",
			"transformation",
			"data",
			"filter",
		],
		img: "switchMapTo.png",
		description: "Maps each source value to the ***same*** given Observable {{innerObservable}} regardless \
of the source value, and then flattens those resulting Observables into one single Observable, \
which is the output Observable.  \
The output Observables emits values only from the most recently emitted instance of innerObservable.",
	},

	groupBy: {
		categories: [
			"subscription",
			"transformation",
		],
		img: "groupBy.png",
		description: "Groups the items emitted by an Observable according to a specified criterion, \
and emits these grouped items as {{GroupedObservables}}, one {{GroupedObservable}} per group.",
	},

	partition: {
		categories: [
			"subscription",
			"transformation",
		],
		img: "partition.png",
		description: "Splits the source Observable into two, one with values that satisfy a predicate, \
and another with values that don't satisfy the predicate.",
	},

	map: {
		categories: [
			"transformation",
			"data",
		],
		img: "map.png",
		description: "Similar to the well known {{Array.prototype.map}} function, \
this operator applies a projection to each value and emits that projection in the output Observable.",
	},

	mapTo: {
		categories: [
			"transformation",
			"data",
		],
		img: "mapTo.png",
		description: "Emits the ***same*** given constant value on the output Observable \
every time the source Observable emits a value.",
	},

	pluck: {
		categories: [
			"transformation",
			"data",
		],
		img: "pluck.png",
		description: "Given a list of strings describing a path to an object property, \
retrieves the value of a specified nested property from all values in the source Observable.  \
If a property can't be resolved, it will return {{undefined}} for that value.",
	},

	scan: {
		categories: [
			"transformation",
			"data",
		],
		img: "scan.png",
		description: "Applies an accumulator function over the source Observable, \
and returns each intermediate result, with an optional seed value.  \
It's like reduce, but emits the current accumulation whenever the source emits a value.  \
Especially useful for evolving state over time.",
	},

	pairwise: {
		categories: [
			"transformation",
			"data",
		],
		img: "pairwise.png",
		description: "Puts the current value and previous value together as an array, and emits that.  \
The Nth emission from the source Observable will cause the output Observable to emit an array [(N-1)th, Nth] \
of the previous and the current value, as a pair.  \
For this reason, pairwise emits on the second and subsequent emissions from the source Observable, \
but not on the first emission, because there is no previous value in that case.",
	},

	mergeScan: {
		categories: [
			"transformation",
			"subscription",
			"data",
		],
		description: "Applies an accumulator function over the source Observable where the accumulator \
function itself returns an Observable, then each intermediate Observable returned is \
merged into the output Observable.  \
It's like scan, but the Observables returned by the accumulator are merged into the outer Observable.",
	},

	delay: {
		categories: [
			"transformation",
			"data",
			"time",
		],
		img: "delay.png",
		description: "Delays the emission of items from the source Observable by a given timeout or until a given \
Date.  \
It time shifts each item by some specified amount of milliseconds.",
	},

	delayWhen: {
		categories: [
			"transformation",
			"data",
			"time",
		],
		img: "delayWhen.png",
		description: 'Time shifts each emitted value from the source Observable by a time span determined by \
another Observable.  \
When the source emits a value, the {{delayDurationSelector}} function is called with the source value as argument, \
and should return an Observable, called the "duration" Observable. \
The source value is emitted on the output Observable only when the duration Observable emits a value or completes.  \
It\'s like delay, but the time span of the delay duration is determined by a second Observable.',
	},

	materialize: {
		categories: [
			"transformation",
			"data",
			"completion",
			"error",
		],
		img: "materialize.png",
		description: "Represents all of the notifications from the source Observable \
as next emissions marked with their original types within {{Notification}} objects.  \
It wraps *next*, *error* and *complete* emissions in {{Notification}} objects, \
emitted as next on the output Observable.",
	},

	dematerialize: {
		categories: [
			"transformation",
			"data",
			"completion",
			"error",
		],
		img: "dematerialize.png",
		description: "Converts an Observable of {{Notification}} objects into the emissions that they represent.  \
It unwraps {{Notification}} objects as actual *next*, *error* and *complete* emissions. The opposite of materialize.",
	},

	subscribeOn: {
		categories: [
			"transformation",
			"subscription",
		],
		img: "subscribeOn.png",
		description: "Returns an observable that subscribes asynchronously to the source-observable \
on the provided *scheduler*.",
	},

	observeOn: {
		categories: [
			"transformation",
			"subscription",
		],
		description: "Returns an observable that emits asynchronously values from the source-observable \
on the provided *scheduler*.",
	},

	timeInterval: {
		categories: [
			"transformation",
			"data",
		],
		img: "timeInterval.png",
		description: "Returns an observable that emits the emits *source-observable* values, \
with the time passed since the previous emitted value.",
	},

	// Filtering operators
	debounce: {
		categories: [
			"filter",
			"time",
		],
		img: "debounce.png",
		description: "Delays values emitted by the source Observable, but drops previous pending delayed emissions \
if a new value arrives on the source Observable.  \
This operator keeps track of the most recent value from the source Observable, and spawns a duration Observable \
by calling the {{durationSelector}} function. \
The value is emitted only when the duration Observable emits a value or completes, and if no other value was \
emitted on the source Observable since the duration Observable was spawned.  \
If a new value appears before the duration Observable emits, the previous value will be dropped \
and will not be emitted on the output Observable.",
	},

	audit: {
		categories: [
			"filter",
			"time",
		],
		img: "audit.png",
		description: 'It is similar to throttle, but emits the last value from the silenced time window, \
instead of the first value.  \
{{audit}} emits the most recent value from the source Observable on the output Observable as soon as \
its internal timer becomes disabled, and ignores source values while the timer is enabled.  \
Initially, the timer is disabled. As soon as the first source value arrives, the timer is enabled \
by calling the {{durationSelector}} function with the source value, which returns the "duration" Observable.  \
When the duration Observable emits a value or completes, the timer is disabled, \
then the most recent source value is emitted on the output Observable, \
and this process repeats for the next source value.',
	},

	auditTime: {
		categories: [
			"filter",
			"time",
		],
		description: "It is just like using {{audit(Observable.interval(time))}}.",
	},

	sample: {
		categories: [
			"filter",
			"time",
			"completion",
		],
		img: "sample.png",
		description: "Emits the most recently emitted value from the source Observable whenever another \
Observable, the {{notifier}}, emits.  \
Whenever the {{notifier}} Observable emits a value or completes, sample looks at the source Observable \
and emits whichever value it has most recently emitted since the previous sampling, \
unless the source has not emitted anything since the previous sampling.  \
The {{notifier}} is subscribed to as soon as the output Observable is subscribed.",
	},

	sampleTime: {
		categories: [
			"filter",
			"time",
			"completion",
		],
		description: "It is just like using {{sample(Observable.interval(time))}}.",
	},

	debounceTime: {
		categories: [
			"filter",
			"time",
		],
		img: "debounceTime.png",
		description: "Delays values emitted by the source Observable, but drops previous pending delayed \
emissions if a new value arrives on the source Observable.  \
This operator keeps track of the most recent value from the source Observable, \
and emits that only when {{dueTime}} enough time has passed without any other value appearing on the source \
Observable.  \
If a new value appears before {{dueTime}} silence occurs, \
the previous value will be dropped and will not be emitted on the output Observable.  \
This is a rate-limiting operator, because it is impossible for more than one value to be emitted \
in any time window of duration {{dueTime}}, but it is also a delay-like operator since output emissions \
do not occur at the same time as they did on the source Observable.  \
Optionally takes a {{IScheduler}} for managing timers.",
	},

	throttle: {
		categories: [
			"filter",
		],
		img: "throttle.png",
		description: 'It\'s like throttleTime, but the silencing duration is determined by a second Observable.\
\
Seriously, go read about {{throttleTime}}, then come back here.\
\
{{throttle}} emits the source Observable values on the output Observable when its internal timer is disabled, \
and ignores source values when the timer is enabled.  \
Initially, the timer is disabled. As soon as the first source value arrives, \
it is forwarded to the output Observable, and then the timer is enabled by calling the {{durationSelector}} \
function with the source value, which returns the "duration" Observable.  \
When the duration Observable emits a value or completes, the timer is disabled, and this process repeats \
for the next source value.',
	},

	throttleTime: {
		categories: [
			"filter",
		],
		img: "throttleTime.png",
		desciption: "Emits the source Observable values on the output Observable when its internal timer is \
disabled, and ignores source values when the timer is enabled.  \
Initially, the timer is disabled. As soon as the first source value arrives, it is forwarded to \
the output Observable, and then the timer is enabled.  \
After {{duration}} milliseconds has passed, the timer is disabled, and this process repeats for the next source value.",
	},

	distinct: {
		categories: [
			"filter",
		],
		img: "distinct.png",
		description: "Returns an Observable that emits all items emitted by the source Observable that are \
distinct by comparison from previous items.\
\
If a {{keySelector}} function is provided, then it will project each value from the source observable into \
a new value that it will check for equality with previously projected values.  \
If a {{keySelector}} function is not provided, it will use each value from the source observable directly \
with an equality check against previous values.",
	},

	distinctUntilChanged: {
		categories: [
			"filter",
		],
		img: "distinctUntilChanged.png",
		description: "Returns an Observable that emits all items emitted by the source Observable \
that are distinct by comparison from the previous item.\
\
If a {{comparator}} function is provided, then it will be called for each item to test for whether or not \
that value should be emitted.\
\
If a {{comparator}} function is not provided, an equality check is used by default.",
	},

	distinctUntilKeyChanged: {
		categories: [
			"filter",
		],
		img: "distinctUntilKeyChanged.png",
		description: "Returns an Observable that emits all items emitted by the source Observable \
that are distinct by comparison from the previous item, \
using a property accessed by using the key provided to check if the two items are distinct.\
\
If a {{comparator}} function is provided, then it will be called for each item to test whether or not \
that value should be emitted.\
\
If a {{comparator}} function is not provided, an equality check is used by default.",
	},

	single: {
		categories: [
			"filter",
			"error",
		],
		img: "single.png",
		description: "Returns an Observable that emits the single item emitted by the source Observable that \
matches a specified {{predicate}}, if that Observable emits one such item.  \
If the source Observable emits more than one such item or no such items, throws of an {{IllegalArgumentException}} \
or {{NoSuchElementException}} respectively.",
	},

	first: {
		categories: [
			"filter",
			"completion",
		],
		img: "first.png",
		description: "Emits only the first value. Or emits only the first value that passes some test."
	},

	elementAt: {
		categories: [
			"filter",
			"completion",
		],
		img: "elementAt.png",
		description: "Returns an Observable that emits the item at the specified {{index}} in the source Observable, \
or a default value if that index is out of range and the {{defaultargument}} is provided.  \
If the default argument is not given and the index is out of range, \
the output Observable will emit an {{ArgumentOutOfRangeError}} error.",
	},

	last: {
		categories: [
			"filter",
		],
		img: "last.png",
		description: "Returns an Observable that emits only the last item emitted by the source Observable.  \
It optionally takes a {{predicate}} function as a parameter, in which case, rather than emitting the last item \
from the source Observable, the resulting Observable will emit the last item from the source Observable that \
satisfies the predicate.",
	},

	filter: {
		categories: [
			"filter",
		],
		img: "filter.png",
		description: "It is similar to the well-known {{Array.prototype.filter}} method. \
This operator takes values from the source Observable, passes them through a predicate function and \
only emits those values that yielded {{true}}.",
	},

	ignoreElements: {
		categories: [
			"filter",
		],
		img: "ignoreElements.png",
		description: "Ignores all items emitted by the source Observable and only passes calls of {{complete}} \
or {{error}}.",
	},

	skip: {
		categories: [
			"filter",
		],
		img: "skip.png",
		description: "Returns an Observable that skips the first {{count}} items emitted by the source Observable.",
	},

	skipUntil: {
		categories: [
			"filter",
		],
		img: "skipUntil.png",
		description: "Returns an Observable that skips items emitted by the source Observable until \
a second Observable emits an item.",
	},

	skipWhile: {
		categories: [
			"filter",
		],
		img: "skipWhile.png",
		description: "Returns an Observable that skips all items emitted by the source Observable \
as long as a specified condition holds {{true}}, \
but emits all further source items as soon as the condition becomes {{false}}.",
	},

	take: {
		categories: [
			"filter",
			"completion",
		],
		img: "take.png",
		description: "Returns an Observable that emits only the first {{count}} values emitted by \
the source Observable.  \
If the source emits fewer than {{count}} values then all of its values are emitted. After that, it completes, \
regardless if the source completes.",
	},

	takeLast: {
		categories: [
			"filter",
			"time",
		],
		img: "takeLast.png",
		description: "Returns an Observable that emits at most the last {{count}} values emitted by \
the source Observable.  \
If the source emits fewer than count values then all of its values are emitted.  \
This operator must wait until the *complete* notification emission from the source in order to emit \
the *next* values on the output Observable, because otherwise it is impossible to know whether or not \
more values will be emitted on the source. For this reason, all values are emitted synchronously, \
followed by the complete notification.",
	},

	takeUntil: {
		categories: [
			"filter",
			"completion",
		],
		img: "takeUntil.png",
		description: "Lets values pass until a second Observable, {{notifier}}, emits something.  \
Then, it completes.",
	},

	takeWhile: {
		categories: [
			"filter",
			"completion",
		],
		img: "takeWhile.png",
		description: "Takes values from the source only while they pass the condition given. \
When the first value does not satisfy, it completes.",
	},
}
